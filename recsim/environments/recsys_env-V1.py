# -*- coding: utf-8 -*-
"""Copie de recsys_env.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c35KqZukq7bogwDU0yKglE_2nCihLBzP
"""

#@title Generic imports
import numpy as np
from gym import spaces
import matplotlib.pyplot as plt
from scipy import stats

"""The main imports we use from RecSim are user and document -- they provide the abstract classes needed to instantiate all components of the environment."""

#@title RecSim imports
from recsim import document
from recsim import user
from recsim.choice_model import MultinomialLogitChoiceModel
from recsim.simulator import environment
from recsim.simulator import recsim_gym
import numpy as np
import random
import uuid
import json
import math
import matplotlib.pyplot as plt

"""***Quality of doc***"""

def quality(mu_low_min,mu_low_max,mu_high_min,mu_high_max,num_low_qual,num_high_qual,sigma=0.1):
	mu_low=[random.uniform(mu_low_min,mu_low_max) for i in range(num_low_qual)]
	mu_hight=[random.uniform(mu_high_min,mu_high_max,) for i in range(num_high_qual)]
	return [np.random.normal(mu_low[i], sigma, 1)[0] for i in range (len(mu_low))]+[np.random.normal(mu_hight[i], sigma, 1)[0] for i in range (len(mu_hight))]

"""***Topic of doc***"""

class Topic():
  def __init__(self,quality):
    self.topic_quality=random.choice(quality)
    self.topic_id=quality.index(self.topic_quality)
    self.topic_list=[_ for _ in range(1,len(quality)+1)]
  
  def __str__(self):
      return "Topic {} with quality {} topic list {}.".format(self.topic_id, self.topic_quality,self.topic_list)

class LTSDocument(document.AbstractDocument):
  def __init__(self, doc_id,inhquality,length,topic):
    self.inhquality=inhquality
    self.length=length
    self.topic = topic
    # doc_id is an integer representing the unique ID of this document
    super(LTSDocument, self).__init__(doc_id)

  """def create_observation(self):
    return np.array([self.inhquality,self.topic,self.length])

  @staticmethod
  def observation_space():
    return spaces.Box(shape=(3,), dtype=np.float32, low=-3.0, high=4.0)"""
  def create_observation(self):
    return {'inhquality': np.array(self.inhquality), 'topic': int(self.topic), 'length':int(self.length)}

  @classmethod
  def observation_space(cls):
    return spaces.Dict({
        'inhquality':
            spaces.Box(
                low=-3.0, high=3.0, shape=tuple(), dtype=np.float32),
        'topic':
            spaces.Discrete(20),

        'length':
            spaces.Discrete(4),
        
    })

  
  
  def __str__(self):
    return "Document {} with quality {} with topic {} with length {}.".format(self._doc_id, self.inhquality,self.topic,self.length)

"""Having implemented a document template, we now need a document sampler. A document sampler is a generative distribution for documents, which will get invoked to regenerate the corpus either after every step or after every session  (depending on runner_lib settings). The object of interest is the sample_document() function required by the base class. It must return a document sampled from our desired distribution. In our case, it returns a document with a kaleness score sampled from a uniform distribution."""

class LTSDocumentSampler(document.AbstractDocumentSampler):
  def __init__(self, doc_ctor=LTSDocument, **kwargs):
    super(LTSDocumentSampler, self).__init__(doc_ctor, **kwargs)
    self._doc_count = 0
  
  def sample_document(self):
    qualite=quality(-3,0,0,3,14,6)
    top=Topic(qualite)
    doc_features = {}
    doc_features['doc_id'] = self._doc_count
    doc_features['inhquality'] = top.topic_quality
    doc_features['topic'] = top.topic_id
    doc_features['length'] = 4
    self._doc_count += 1
    return self._doc_ctor(**doc_features)

"""#A User Model"""

def associateTopicInterest(nb_topic=20):
  ''' Topic =====> user's interest '''
  qualite=quality(-3,0,0,3,14,6)
  topic=Topic(qualite)
  dico=dict(zip(topic.topic_list,list(np.random.uniform(-1,1,nb_topic))))
  dico.update({0:0})
  return dico

def associateTopicInterest(nb_topic=20):
  ''' Topic =====> user's interest '''
  qualite=quality(-3,0,0,3,14,6)
  topic=Topic(qualite)
  dico=dict(zip(topic.topic_list,list(np.random.uniform(-1,1,nb_topic))))
  dico.update({0:0})
  return dico

def userSatisfaction(user,document,alpha=1):
	''' A user’s satisfaction S(u, d) with a consumed document d is a function f(I(u, d), Ld)
	of user u’s interest and document d’s quality. While the form of f may be quite complex
	in general, we assume a simple convex combination S(u, d) = (1 − α)I(u, d) + αLd.'''
	return ((1-alpha)*user.associate_topic_interet[document.topic]+(alpha*document.inhQuality))



class LTSUserState(user.AbstractUserState):
  user.AbstractUserState.NUM_FEATURES = 20
  def __init__(self,time_budget,interest,satisfaction
              ):
    
    ## State variables
    ##############################
    self.interest=interest
    self.satisfaction = satisfaction
    self.time_budget = time_budget

    

  def create_observation(self):
    """User's state is not observable."""
    """clip_low, clip_high = (-1.0 / (1.0 * self._observation_noise),
                           1.0 / (1.0 * self._observation_noise))
    noise = stats.truncnorm(
        clip_low, clip_high, loc=0.0, scale=self._observation_noise).rvs()
    noisy_sat = self.satisfaction + noise"""
    inters=list(self.interest.values())
    return np.array([inters,self.satisfaction,])

  @staticmethod
  def observation_space():
    #return spaces.Box(low=np.array([-3.0,-1.0]),high=np.array([1.0,3.0]), dtype=np.float32)
    return spaces.Box(shape=(2,), dtype=np.float32, low=-3.0, high=3.0)
  
  def create_observation(self):
    return {'interest': np.array(list(self.interest.values())).astype(float), 'satisfaction': np.array(self.satisfaction)}

  @classmethod
  def observation_space(cls):
    return spaces.Dict({
        'interest':
            spaces.Box(
                low=-1.0, high=1.0, shape=tuple(), dtype=np.float32),
        'satisfaction':
            spaces.Box(
                low=-3.0, high=3.0, shape=tuple(), dtype=np.float32),

        
    })

  # scoring function for use in the choice model -- the user is more likely to
  # click on more chocolatey content.
  
  def score_document(self, doc_obs):
    return (0.9/3.4)*doc_obs['length']*self.satisfaction

class LTSStaticUserSampler(user.AbstractUserSampler):
  _state_parameters = None

  def __init__(self,
               user_ctor=LTSUserState,
               time_budget=120,
               satisfaction=0,
               **kwargs):
    self._state_parameters = {'time_budget': time_budget,
                              'satisfaction':satisfaction
                              
                             }
    super(LTSStaticUserSampler, self).__init__(user_ctor, **kwargs)

  def sample_user(self):
    self._state_parameters['interest'] = associateTopicInterest()
    return self._user_ctor(**self._state_parameters)

"""## Response model

The next thing we want to check off our list is the user response class. RecSim will generate one response for every recommended item in the slate. The contents of the response are what the agent will see as document-specific feedback from the recommendation (the non-document specific feedback being generated in LTSUserState.create_observation).
"""

class LTSResponse(user.AbstractResponse):
  # The maximum degree of engagement.
  MAX_ENGAGEMENT_MAGNITUDE = 10.0
  MAX_SATISFACTION_MAGNITUDE = 10.0
  MAX_WATCHTIME_MAGNITUDE = 10.0

  def __init__(self,click=False, engagement=0.0,satisfaction=0.0,watch_time=120,quality=0,cluster_id=0):
    self.click = click
    self.engagement = engagement #bonus
    self.satisfaction=satisfaction
    self.watch_time=watch_time
    self.quality=quality
    self.cluster_id=cluster_id

  def create_observation(self):
    return {'click': int(self.click), 'engagement': np.array(self.engagement),
            'satisfaction': np.array(self.satisfaction),
            'watch_time': float(self.watch_time),
            'quality': np.array(self.quality),
            'cluster_id': int(self.cluster_id),
            }

  @classmethod
  def response_space(cls):
    # `engagement` feature range is [0, MAX_ENGAGEMENT_MAGNITUDE]
    return spaces.Dict({
        'click':
            spaces.Discrete(3),
        'engagement':
            spaces.Box(
                low=0.0,
                high=cls.MAX_ENGAGEMENT_MAGNITUDE,
                shape=tuple(),
                dtype=np.float32),
        'satisfaction':
            spaces.Box(
                low=0.0,
                high=cls.MAX_SATISFACTION_MAGNITUDE,
                shape=tuple(),
                dtype=np.float32),
            
        'watch_time':
            spaces.Box(
                low=0,
                high=120,
                shape=tuple(),
                dtype=np.float32),
            
        'quality':
            spaces.Box(
                low=-3,
                high=3,
                shape=tuple(),
                dtype=np.float32),
            
        'cluster_id':
            spaces.Discrete(21)
    })

"""Our init is simple---we just pass the response_model constructor, user sampler and slate size down to the AbstractUserModel base class. Exploring other environments, the reader might notice that user model __init__ functions do offer a lot of flexibility for configuring the simulation. For now, however, we stick to the basics and hardcode things."""

def user_init(self,
              slate_size,
              seed=0):

  super(LTSUserModel,
        self).__init__(LTSResponse,
                       LTSStaticUserSampler(LTSUserState,
                                            seed=seed), slate_size)
  self.choice_model = MultinomialLogitChoiceModel({})

"""The simulate_response() method takes in a slate (list) of recommended (i.e., produced by the agent) LTSDocuments and must output a slate of user responses. The *k*-th response in the slate of responses corresponds to the *k*-th document in the recommendation slate. In this case, we pick one document to click on based on our choice model, and produce an engagement value. We will let the responses to the unclick documents be vacuous, however, one might use them in more subtle ways (e.g., recording whether the user inspected that document, etc.)."""

def simulate_response(self, slate_documents):
  # List of empty responses
  responses = [self._response_model_ctor() for _ in slate_documents]
  # Get click from of choice model.
  self.choice_model.score_documents(
    self._user_state, [doc.create_observation() for doc in slate_documents])
  scores = self.choice_model.scores
  #selected_index = slate_documents.index(random.choice(slate_documents))
  selected_index = self.choice_model.choose_item()
  # Populate click item.
  """print("user state : ",self._user_state)
  print("selected index : ",selected_index)
  print("document : ",slate_documents)"""
  self._generate_response(slate_documents[selected_index],
                          responses[selected_index])
  return responses

def generate_response(self, doc, response,alpha=0.1):
  response.click = True
  response.satisfaction=(1-alpha)*self._user_state.interest[doc.topic]+(alpha*doc.inhquality)
  bonus=(0.9/3.4)*doc.length*response.satisfaction
  response.quality=doc.inhquality
  response.engagement = bonus
  response.cluster_id=doc.topic

"""The update_state() method implements our state transition kernel. It consumes the recommended slate, as well as the actual choices (responses) to induce a state transition. The state is modified in-place, so the function does not return anything."""

def update_state(self, slate_documents, responses):
  for doc, response in zip(slate_documents, responses):
    if response.click:
      self._user_state.satisfaction = response.satisfaction
      self._user_state.time_budget += response.engagement
      response.watch_time += response.engagement
      return

"""Finally, the session expires when the time budget goes to 0."""

def is_terminal(self):
  """Returns a boolean indicating if the session is over."""
  return self._user_state.time_budget <= 0

"""We have all the components to instantiate a user model, so let's wrap them up in a class."""

LTSUserModel = type("LTSUserModel", (user.AbstractUserModel,),
                    {"__init__": user_init,
                     "is_terminal": is_terminal,
                     "update_state": update_state,
                     "simulate_response": simulate_response,
                     "_generate_response": generate_response})

"""Finally, we assemble all components into an Environment."""

slate_size = 3
 num_candidates = 10
 ltsenv = environment.Environment(
            LTSUserModel(slate_size),
            LTSDocumentSampler(),
            num_candidates,
            slate_size,
            resample_documents=True)

"""## Interacting with an agent

We now have a fully implemented environment in hand. In order to train/evaluate agents in this environment, we first need to specify a reward function. In RecSim, a reward function maps a set of responses to a real number. Suppose we want to maximize the engagement of the click documents.
"""

def click_engagement_reward(responses):
  reward = 0.0
  for response in responses:
    if response.click:
      reward += response.engagement
  return reward

"""Now, we simply use the OpenAI gym wrapper, which essentially provides a familiar step-based API."""

lts_gym_env = recsim_gym.RecSimGymEnv(ltsenv, click_engagement_reward)