# -*- coding: utf-8 -*-
"""recsys_env_finalpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yMbMkRs9t0YQZ0fZQvH8bYssTnK6CMW7
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from absl import flags
from absl import logging
import gin.tf
from gym import spaces
import numpy as np
from recsim import choice_model
from recsim import document
from recsim import user
from recsim import utils
from recsim.simulator import environment
from recsim.simulator import recsim_gym
import random
import math

FLAGS = flags.FLAGS

def quality(mu_low_min=-3,mu_low_max=0,mu_high_min=0,mu_high_max=3,num_low_qual=14,num_high_qual=6,sigma=0.1):
	mu_low=[random.uniform(mu_low_min,mu_low_max) for i in range(num_low_qual)]
	mu_hight=[random.uniform(mu_high_min,mu_high_max,) for i in range(num_high_qual)]
	return [np.random.normal(mu_low[i], sigma, 1)[0] for i in range (len(mu_low))]+[np.random.normal(mu_hight[i], sigma, 1)[0] for i in range (len(mu_hight))]

class Topic():
  def __init__(self,quality):
    self.topic_quality=random.choice(quality)
    '''if quality.index(self.topic_quality)==0
      self.topic_id=1'''
    self.topic_id=quality.index(self.topic_quality)
  
  def __str__(self):
      return "Topic {} with quality {}.".format(self.topic_id, self.topic_quality)

class IEvResponse(user.AbstractResponse):
  """Class to represent a user's response to a doc.
  Attributes:
    clicked: A boolean indicating whether the doc was clicked.
    watch_time: A float for fraction of the doc watched.
    liked: A boolean indicating whether the doc was liked.
    quality: A float indicating the quality of the doc.
    cluster_id: A integer representing the cluster ID of the doc.
  """

  # The min quality score.
  MIN_QUALITY_SCORE = -3
  # The max quality score.
  MAX_QUALITY_SCORE = 3

  def __init__(self,
               clicked=False,
               watch_time=0.0,
               quality=0.0,
               cluster_id=0.0,
               satisfaction=0.0,
               bonus=0.0):
    """Creates a new user response for a doc.
    Args:
      clicked: A boolean indicating whether the doc was clicked
      watch_time: le nombre d'unité consommé qu'ont va diminuer sur le budget de l'utilisateur
      liked: A boolean indicating whether the doc was liked
      quality: A float for document quality
      cluster_id: a integer for the topic ID of the document.
    """
    self.clicked = clicked
    self.watch_time = watch_time 
    self.quality = quality
    self.cluster_id = cluster_id
    self.satisfaction=satisfaction
    self.bonus=bonus

  def create_observation(self):
    return {
        'click': int(self.clicked),
        'watch_time': np.array(self.watch_time),
        'quality': np.array(self.quality),
        'cluster_id': int(self.cluster_id),
        'satisfaction': np.array(self.satisfaction),
        'bonus': np.array(self.satisfaction)
    }

  @classmethod
  def response_space(cls):
    # `clicked` feature range is [0, 1]
    # `watch_time` feature range is [0, 7] MAX_QUALITY_SCORE + doc_ength=3+4
    # `liked` feature range is [0, 1]
    # `quality`: the quality of the document and range is specified by
    #    [MIN_QUALITY_SCORE, MAX_QUALITY_SCORE].
    # `cluster_id`: the cluster the document belongs to and its range is
    # .  [0, 20].
    return spaces.Dict({
        'click':
            spaces.Discrete(2),
        'watch_time':
            spaces.Box(
                low=0.0,
                high=7.0,
                shape=tuple(),
                dtype=np.float32),
        'quality':
            spaces.Box(
                low=cls.MIN_QUALITY_SCORE,
                high=cls.MAX_QUALITY_SCORE,
                shape=tuple(),
                dtype=np.float32),
        'cluster_id':
            spaces.Discrete(21),
        'satisfaction':
            spaces.Box(
                low=cls.MIN_QUALITY_SCORE,
                high=cls.MAX_QUALITY_SCORE,
                shape=tuple(),
                dtype=np.float32), 
        'bonus':
            spaces.Box(
                low=cls.MIN_QUALITY_SCORE,
                high=cls.MAX_QUALITY_SCORE,
                shape=tuple(),
                dtype=np.float32),   
    })


class IEvdoc(document.AbstractDocument):
  """Class to represent a interest evolution doc.
  Attributes:
    features: A numpy array that stores doc features.
    cluster_id: An integer that represents.
    doc_length : A float for doc length.
    quality: a float the represents document quality.
  """

  # The maximum length of docs.
  MAX_DOC_LENGTH = 4

  # The number of features to represent each doc.
  NUM_FEATURES = 20

  def __init__(self,
               doc_id,
               features,
               cluster_id=None,
               length=4.0,
               quality=None):
    """Generates a random set of features for this interest evolution doc."""

    # Document features (i.e. distribution over topics)
    self.features = features

    # Cluster ID
    self.cluster_id = cluster_id

    # Length of doc
    self.length = length

    # Document quality (i.e. trashiness/nutritiousness)
    self.quality = quality

    # doc_id is an integer representing the unique ID of this document
    super(IEvdoc, self).__init__(doc_id)

  def create_observation(self):
    """Returns observable properties of this document as a float array."""
    return self.features

  @classmethod
  def observation_space(cls):
    return spaces.Box(
        shape=(cls.NUM_FEATURES,), dtype=np.float32, low=-1.0, high=1.0)

  def __str__(self):
      return "Id {} Topic {} with quality {} with length {}.".format(self._doc_id,self.cluster_id, self.quality,self.length)


class IEvdocSampler(document.AbstractDocumentSampler):
  """Class to sample interest_evolution docs."""

  def __init__(self,
               doc_ctor=IEvdoc,
               min_feature_value=-1.0,
               max_feature_value=1.0,
               length=4.0,
               **kwargs):
    """Creates a new interest evolution doc sampler.
    Args:
      doc_ctor: A class/constructor for the type of docs that will be sampled
        by this sampler.
      min_feature_value: A float for the min feature value.
      max_feature_value: A float for the max feature value.
      doc_length_mean: A float for the mean of the doc length.
      doc_length_std: A float for the std deviation of doc length.
      **kwargs: other keyword parameters for the doc sampler.
    """
    super(IEvdocSampler, self).__init__(doc_ctor, **kwargs)
    self._doc_count = 0
    self._min_feature_value = min_feature_value
    self._max_feature_value = max_feature_value
    #self._doc_length_mean = doc_length_mean
    self._length = length

  def sample_document(self):
    qualite=quality()
    top=Topic(qualite)
    doc_features = {}
    doc_features['doc_id'] = self._doc_count
    # For now, assume the document properties are uniform random.
    # It will probably make more sense to concentrate the interests around a few
    # (e.g. 5?) categories or have a more sophisticated generative process?
    doc_features['features'] = self._rng.uniform(
        self._min_feature_value, self._max_feature_value,
        self.get_doc_ctor().NUM_FEATURES)
    
    doc_features['length'] = self._length
    doc_features['quality'] = top.topic_quality
    self._doc_count += 1
    return self._doc_ctor(**doc_features)


class UtilityModeldocSampler(document.AbstractDocumentSampler):
  """Class that samples docs for utility model experiment."""

  def __init__(self,
               doc_ctor=IEvdoc,
               length=4.0,
               **kwargs):
    """Creates a new utility model doc sampler.
    Args:
      doc_ctor: A class/constructor for the type of docs that will be sampled
        by this sampler.
      min_utility: A float for the min utility score.
      max_utility: A float for the max utility score.
      doc_length: A float for the doc_length in minutes.
      **kwargs: other keyword parameters for the doc sampler.
    """
    super(UtilityModeldocSampler, self).__init__(doc_ctor, **kwargs)
    
    self._doc_count = 0
    self._num_clusters = 20
    self._length = length


  def sample_document(self):
    qualite=quality()
    top=Topic(qualite)
    doc_features = {}
    doc_features['doc_id'] = self._doc_count

    # Sample a cluster_id. Assumes there are NUM_FEATURE clusters.
    cluster_id = top.topic_id
    doc_features['cluster_id'] = cluster_id

    # Features are a 1-hot encoding of cluster id
    features = np.zeros(self._num_clusters)
    features[cluster_id] = 1.0
    doc_features['features'] = features

    # Fixed doc lengths (in minutes)
    doc_features['length'] = self._length

    
    doc_features['quality'] = top.topic_quality

    self._doc_count += 1
    return self._doc_ctor(**doc_features)


class IEvUserState(user.AbstractUserState):
  """Class to represent interest evolution users."""

  # Number of features in the user state representation.
  NUM_FEATURES = 20

  def __init__(self,
               user_interests,
               time_budget=0.0,
               satisfaction=0.0):
    """Initializes a new user."""

    # Only user_interests is required, since it is needed to create an
    # observation. It is the responsibility of the designer to make sure any
    # other variables that are needed in the user choice/transition model are
    # also provided.

    ## User features
    #######################

    # The user's interests (1 = very interested, -1 = disgust)
    # Another option could be to represent in [0,1] e.g. by dirichlet
    self.user_interests = user_interests

    # Amount of time in minutes this user has left in session.
    self.time_budget = time_budget
    
    self.satisfaction=satisfaction

    # Convenience wrapper
    self.choice_features = {
        
        #'no_click_mass': no_click_mass,
        
    }

   
   

  def score_document(self, doc_obs,tau=1): #tau constante of ogit model
    if self.user_interests.shape != doc_obs.shape:
      raise ValueError('User and document feature dimension mismatch!')
      #unnormalized probability v(xij ) In the case of the conditional logit, v(xij ) = exp(τu(xij ))
    return math.exp(tau*np.dot(self.user_interests, doc_obs)) #return math.exp(tau*self.user_interests)#

  def create_observation(self):
    """Return an observation of this user's observable state."""
    return self.user_interests

  @classmethod
  def observation_space(cls):
    return spaces.Box(
        shape=(cls.NUM_FEATURES,), dtype=np.float32, low=-1.0, high=1.0)


class IEvUserDistributionSampler(user.AbstractUserSampler):
  """Class to sample users by a hardcoded distribution."""

  def __init__(self, user_ctor=IEvUserState, **kwargs):
    """Creates a new user state sampler."""
    logging.debug('Initialized IEvUserDistributionSampler')
    super(IEvUserDistributionSampler, self).__init__(user_ctor, **kwargs)

  def sample_user(self):
    """Samples a new user, with a new set of features."""

    features = {}
    features['user_interests'] = np.random.uniform(-1.0,1.0,NUM_FEATURES)
    features['time_budget'] = 120
    #features['no_click_mass'] = 1
    features['liked_docs'] = set()
    features['satisfaction'] = 0.0
    return self._user_ctor(**features)


@gin.configurable
class UtilityModelUserSampler(user.AbstractUserSampler):
  """Class that samples users for utility model experiment."""

  def __init__(self,
               user_ctor=IEvUserState,
               #document_quality_factor=1.0,
               #no_click_mass=1.0,
               #min_normalizer=-1.0,
               satisfaction=0.0,
               **kwargs):
    """Creates a new user state sampler."""
    logging.debug('Initialized UtilityModelUserSampler')
    self.satisfaction=satisfaction
    super(UtilityModelUserSampler, self).__init__(user_ctor, **kwargs)

  def sample_user(self):
    features = {}
    # Interests are distributed uniformly randomly
    features['user_interests'] = self._rng.uniform(
        -1.0, 1.0,
        self.get_user_ctor().NUM_FEATURES)
    # Assume all users have fixed amount of time
    features['time_budget'] = 120.0  # 120.0

    return self._user_ctor(**features)


class IEvUserModel(user.AbstractUserModel):
  """Class to model an interest evolution user.
  Assumes the user state contains:
    - user_interests
    - time_budget
    - no_click_mass
  """

  def __init__(self,
               slate_size,
               choice_model_ctor=None,
               response_model_ctor=IEvResponse,
               user_state_ctor=IEvUserState,
               #no_click_mass=1.0,
               seed=0,
               ):
   
    super(IEvUserModel, self).__init__(
        response_model_ctor,
        UtilityModelUserSampler(
            user_ctor=user_state_ctor, seed=seed),
        slate_size)
    if choice_model_ctor is None:
      raise Exception('A choice model needs to be specified!')
    self.choice_model = choice_model_ctor(self._user_state.choice_features)

    

  def is_terminal(self):
    """Returns a boolean indicating if the session is over."""
    return self._user_state.time_budget <= 0

  def update_state(self, slate_documents, responses,alpha=1,y=0.3):

    user_state = self._user_state

    for doc, response in zip(slate_documents, responses): 
      if response.clicked: 
        self.choice_model.score_documents(
            user_state, [doc.create_observation()])
        score=self.choice_model.scores

        user_state.satisfaction=(1-alpha)*user_state.user_interests[doc.cluster_id]+(alpha*doc.quality)
      
        # update budget
        user_state.time_budget += response.watch_time
        

        #update user interest
        #The (absolute) change i user u’s interest is ∆t(It) = (−y|It| + y) · −It
        # where y ∈ [0, 1] denotes the fraction of the
        #distance between the current interest level and the maximum level (1, −1) that the update
        #move user u’s interest.
        change_interest=(-y*abs(user_state.user_interests[doc.cluster_id])+y)*(-user_state.user_interests[doc.cluster_id])
        """ A positive change in interest, It ← It + ∆t(It),
        occurs with probability [I(u, d) + 1]/2, and a negative change, It ← It − ∆t(It), with
        probability [1 − I(u, d)]/2.  """
        if score >= (user_state.user_interests[doc.cluster_id]+1)/2:
          user_state.user_interests[doc.cluster_id]+=change_interest
        elif score <= (-user_state.user_interests[doc.cluster_id]+1)/2 :
          user_state.user_interests[doc.cluster_id]-=change_interest
        return
    
    

  def simulate_response(self, documents):
    """Simulates the user's response to a slate of documents with choice model.
    Args:
      documents: a list of IEvdoc objects
    Returns:
      responses: a list of IEvResponse objects, one for each document
    """
    # Add null doc
    nulldoc=IEvdoc(None,np.zeros(20),-1,quality=0)
    documents[len(documents)-1]=nulldoc

    # List of empty responses
    responses = [self._response_model_ctor() for _ in documents]
    
    # Sample some clicked responses using user's choice model and populate
    # responses.
    doc_obs = [doc.create_observation() for doc in documents]
    
    self.choice_model.score_documents(self._user_state, doc_obs)
   
    selected_index = self.choice_model.choose_item()
    
    
    for i, response in enumerate(responses):
      response.quality = documents[i].quality
      response.cluster_id = documents[i].cluster_id
      

    if selected_index is None:
      return responses
    self._generate_click_response(documents[selected_index],
                                  responses[selected_index])

    return responses

  def _generate_click_response(self, doc, response,alpha=1):
    user_state = self._user_state
    response.clicked = True
    user_state.satisfaction=(1-alpha)*user_state.user_interests[doc.cluster_id]+(alpha*doc.quality)
    
    response.bonus=(0.9/3.4)*doc.length*user_state.satisfaction

    if response.cluster_id==-1 :#nul doc clicked 
      response.watch_time = -0.5
    else :
      response.watch_time = -doc.length+response.bonus
    response.satisfaction=user_state.satisfaction



def clicked_watchtime_reward(responses):
  """Calculates the total clicked watchtime from a list of responses.
  Args:
    responses: A list of IEvResponse objects
  Returns:
    reward: A float representing the total watch time from the responses
  """
  reward = 0.0
  for response in responses:
    if response.clicked:
      reward += response.bonus
  return reward


def total_clicks_reward(responses):
  """Calculates the total number of clicks from a list of responses.
  Args:
     responses: A list of IEvResponse objects
  Returns:
    reward: A float representing the total clicks from the responses
  """
  reward = 0.0
  for r in responses:
    reward += r.clicked
  return reward


def create_environment(env_config):
  """Creates an interest evolution environment."""

  user_model = IEvUserModel(
      env_config['slate_size'],
      choice_model_ctor=choice_model.MultinomialLogitChoiceModel,
      response_model_ctor=IEvResponse,
      user_state_ctor=IEvUserState,
      seed=env_config['seed'])

  document_sampler = UtilityModeldocSampler(
      doc_ctor=IEvdoc, seed=env_config['seed'])

  ievenv = environment.Environment(
      user_model,
      document_sampler,
      env_config['num_candidates'],
      env_config['slate_size'],
      resample_documents=env_config['resample_documents'])

  return recsim_gym.RecSimGymEnv(ievenv, clicked_watchtime_reward,
                                 utils.aggregate_video_cluster_metrics,
                                 utils.write_video_cluster_metrics)
