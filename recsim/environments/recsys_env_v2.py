# -*- coding: utf-8 -*-
"""recsys_env-V2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rb4X-yJzajMB9IOJ_b14gLI_3PTLHAdr
"""

#@title Generic imports
import numpy as np
from gym import spaces
import matplotlib.pyplot as plt
from scipy import stats

"""The main imports we use from RecSim are user and document -- they provide the abstract classes needed to instantiate all components of the environment."""

#@title RecSim imports
from recsim import document
from recsim import user
from recsim.choice_model import MultinomialLogitChoiceModel
from recsim.simulator import environment
from recsim.simulator import recsim_gym
import numpy as np
import random
import uuid
import json
import math
import matplotlib.pyplot as plt

"""***Quality of doc***"""

def quality(mu_low_min,mu_low_max,mu_high_min,mu_high_max,num_low_qual,num_high_qual,sigma=0.1):
	mu_low=[random.uniform(mu_low_min,mu_low_max) for i in range(num_low_qual)]
	mu_hight=[random.uniform(mu_high_min,mu_high_max,) for i in range(num_high_qual)]
	return [np.random.normal(mu_low[i], sigma, 1)[0] for i in range (len(mu_low))]+[np.random.normal(mu_hight[i], sigma, 1)[0] for i in range (len(mu_hight))]

"""***Topic of doc***"""

class Topic():
  def __init__(self,quality):
    self.topic_quality=random.choice(quality)
    self.topic_id=quality.index(self.topic_quality)
    self.topic_list=[_ for _ in range(1,len(quality)+1)]
  
  def __str__(self):
      return "Topic {} with quality {} topic list {}.".format(self.topic_id, self.topic_quality,self.topic_list)

class LTSDocument(document.AbstractDocument):
  def __init__(self, doc_id,inhquality,length,topic):
    self.inhquality=inhquality
    self.length=length
    self.topic = topic
    # doc_id is an integer representing the unique ID of this document
    super(LTSDocument, self).__init__(doc_id)

  def create_observation(self):
    return {'inhquality': np.array(self.inhquality), 'topic': int(self.topic), 'length':int(self.length)}

  @classmethod
  def observation_space(cls):
    return spaces.Dict({
        'inhquality':
            spaces.Box(
                low=-3.0, high=3.0, shape=tuple(), dtype=np.float32),
        'topic':
            spaces.Discrete(20),

        'length':
            spaces.Discrete(4),
        
    })

  
  
  def __str__(self):
    return "Document {} with quality {} with topic {} with length {}.".format(self._doc_id, self.inhquality,self.topic,self.length)

class LTSDocumentSampler(document.AbstractDocumentSampler):
  def __init__(self, doc_ctor=LTSDocument, **kwargs):
    super(LTSDocumentSampler, self).__init__(doc_ctor, **kwargs)
    self._doc_count = 1
  
  def sample_document(self):
    qualite=quality(-3,0,0,3,14,6)
    top=Topic(qualite)
    doc_features = {}
    doc_features['doc_id'] = self._doc_count
    doc_features['inhquality'] = top.topic_quality
    doc_features['topic'] = top.topic_id
    doc_features['length'] = 4
    self._doc_count += 1
    return self._doc_ctor(**doc_features)

def associateTopicInterest(nb_topic=20):
  ''' Topic =====> user's interest '''
  qualite=quality(-3,0,0,3,14,6)
  topic=Topic(qualite)
  dico=dict(zip(topic.topic_list,list(np.random.uniform(-1,1,nb_topic))))
  dico.update({0:0})
  return dico

def associateTopicInterest(nb_topic=20):
  ''' Topic =====> user's interest '''
  qualite=quality(-3,0,0,3,14,6)
  topic=Topic(qualite)
  dico=dict(zip(topic.topic_list,list(np.random.uniform(-1,1,nb_topic))))
  dico.update({0:0})
  return dico

def userSatisfaction(user,document,alpha=1):
	''' A user’s satisfaction S(u, d) with a consumed document d is a function f(I(u, d), Ld)
	of user u’s interest and document d’s quality. While the form of f may be quite complex
	in general, we assume a simple convex combination S(u, d) = (1 − α)I(u, d) + αLd.'''
	return ((1-alpha)*user.associate_topic_interet[document.topic]+(alpha*document.inhQuality))



class LTSUserState(user.AbstractUserState):
  user.AbstractUserState.NUM_FEATURES = 20
  def __init__(self,time_budget,interest,satisfaction
              ):
    
    ## State variables
    ##############################
    self.interest=interest
    self.satisfaction = satisfaction
    self.time_budget = time_budget

    

  def create_observation(self):
    inters=list(self.interest.values())
    return np.array([inters,self.satisfaction,])

  @staticmethod
  def observation_space():
    #return spaces.Box(low=np.array([-3.0,-1.0]),high=np.array([1.0,3.0]), dtype=np.float32)
    return spaces.Box(shape=(2,), dtype=np.float32, low=-3.0, high=3.0)
  
  def create_observation(self):
    return {'interest': np.array(list(self.interest.values())).astype(float), 'satisfaction': np.array(self.satisfaction)}

  @classmethod
  def observation_space(cls):
    return spaces.Dict({
        'interest':
            spaces.Box(
                low=-1.0, high=1.0, shape=tuple(), dtype=np.float32),
        'satisfaction':
            spaces.Box(
                low=-3.0, high=3.0, shape=tuple(), dtype=np.float32),

        
    })

  # scoring function for use in the choice model -- the user is more likely to
  # click on more chocolatey content.
  
  def score_document(self, doc_obs):
    return (0.9/3.4)*doc_obs['length']*self.satisfaction

class LTSStaticUserSampler(user.AbstractUserSampler):
  _state_parameters = None

  def __init__(self,
               user_ctor=LTSUserState,
               time_budget=120,
               satisfaction=0,
               **kwargs):
    self._state_parameters = {'time_budget': time_budget,
                              'satisfaction':satisfaction
                              
                             }
    super(LTSStaticUserSampler, self).__init__(user_ctor, **kwargs)

  def sample_user(self):
    self._state_parameters['interest'] = associateTopicInterest()
    return self._user_ctor(**self._state_parameters)

class LTSResponse(user.AbstractResponse):
  # The maximum degree of engagement.
  MAX_ENGAGEMENT_MAGNITUDE = 10.0
  MAX_SATISFACTION_MAGNITUDE = 10.0
  MAX_WATCHTIME_MAGNITUDE = 10.0

  def __init__(self,click=False,watch_time=120,quality=0,cluster_id=0):#,engagement=0.0,satisfaction=0.0,):
    self.click = click
    self.watch_time=watch_time
    self.quality=quality
    self.cluster_id=cluster_id
    '''self.engagement=engagement
    self.satisfaction=satisfaction'''

  def create_observation(self):
    return {'click': int(self.click),
            'watch_time': float(self.watch_time),
            'quality': float(self.quality),
            'cluster_id': int(self.cluster_id),
            }

  @classmethod
  def response_space(cls):
    # `engagement` feature range is [0, MAX_ENGAGEMENT_MAGNITUDE]
    return spaces.Dict({
        'click':
            spaces.Discrete(3),
            
        'watch_time':
            spaces.Box(
                low=0,
                high=120,
                shape=tuple(),
                dtype=np.float32),
            
        'quality':
            spaces.Box(
                low=-3,
                high=3,
                shape=tuple(),
                dtype=np.float32),
            
        'cluster_id':
            spaces.Discrete(21)
    })

def user_init(self,
              slate_size,
              seed=0):

  super(LTSUserModel,
        self).__init__(LTSResponse,
                       LTSStaticUserSampler(LTSUserState,
                                            seed=seed), slate_size)
  self.choice_model = MultinomialLogitChoiceModel({})

def simulate_response(self, slate_documents):
  #Add null doc
  slate_documents.append(LTSDocument(0,0,0,0))
  # List of empty responses
  responses = [self._response_model_ctor() for _ in slate_documents]
  # Get click from of choice model.
  self.choice_model.score_documents(
    self._user_state, [doc.create_observation() for doc in slate_documents])
  scores = self.choice_model.scores
  #selected_index = slate_documents.index(random.choice(slate_documents))
  selected_index = self.choice_model.choose_item()
  # Populate click item.
  """print("user state : ",self._user_state)"""
  print("Les documents dans le slate : ")
  for doc in slate_documents:
    print(doc.__str__())
  self._generate_response(slate_documents[selected_index],
                          responses[selected_index])
  return responses

def generate_response(self, doc, response,alpha=0.1):
  response.click = True
  response.satisfaction=(1-alpha)*self._user_state.interest[doc.topic]+(alpha*doc.inhquality)
  bonus=(0.9/3.4)*doc.length*response.satisfaction
  response.quality=doc.inhquality
  response.engagement = bonus
  response.watch_time = self._user_state.time_budget
  response.cluster_id=doc.topic

def update_state(self, slate_documents, responses):
  for doc, response in zip(slate_documents, responses):
    if response.click:
      self._user_state.satisfaction = response.satisfaction
      self._user_state.time_budget += response.engagement
      return

"""Finally, the session expires when the time budget goes to 0."""

def is_terminal(self):
  """Returns a boolean indicating if the session is over."""
  return self._user_state.time_budget <= 0

"""We have all the components to instantiate a user model, so let's wrap them up in a class."""

LTSUserModel = type("LTSUserModel", (user.AbstractUserModel,),
                    {"__init__": user_init,
                     "is_terminal": is_terminal,
                     "update_state": update_state,
                     "simulate_response": simulate_response,
                     "_generate_response": generate_response})

"""Finally, we assemble all components into an Environment."""

slate_size = 3
num_candidates = 10
ltsenv = environment.Environment(
    LTSUserModel(slate_size),
    LTSDocumentSampler(),
    num_candidates,
    slate_size,
    resample_documents=True)

def click_engagement_reward(responses):
  reward = 0.0
  for response in responses:
    if response.click:
      reward += response.engagement
  return reward

"""Now, we simply use the OpenAI gym wrapper, which essentially provides a familiar step-based API."""

lts_gym_env = recsim_gym.RecSimGymEnv(ltsenv, click_engagement_reward)
